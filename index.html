<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Spotify Soundboard</title>
  
  <script src="https://developer.spotify.com/documentation/web-api/tutorials/code-pkce-flow"></script>

  <style>
    /* All your advanced CSS goes here... */
    /* --- Base & Layout --- */
    html, body { height: 100%; width: 100%; margin: 0; padding: 0; overflow: hidden; }
    body { font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 16px; padding: 24px; background: #004a9a; color: #e6eef3; box-sizing: border-box; }
    /* --- Auth & Status Area --- */
    .auth-area { display: flex; flex-direction: column; gap: 10px; width: 100%; max-width: 500px; }
    .auth-area .auth-buttons { display: flex; gap: 10px; }
    .auth-area .auth-buttons button { flex-grow: 1; padding: 10px; border-radius: 8px; border: 0; background: #1db954; color: #052012; font-weight: 600; cursor: pointer; }
    .auth-area .auth-buttons button.muted { background: #2c2f33; color: #e6eef3; }
    /* --- Info Displays --- */
    .info { font-size: 14px; color: #c0d4ff; min-height: 1.2em; text-align: center; font-weight: 500; }
    /* --- Currently Playing UI --- */
    .track-info { display: flex; flex-direction: column; align-items: center; justify-content: center; background: #0a0a0e; border-radius: 12px; padding: 16px; width: 100%; max-width: 420px; box-sizing: border-box; min-height: 80px; text-align: center; }
    .track-name { font-size: 1.1rem; font-weight: 600; color: #fff; margin: 0; }
    .track-artist { font-size: 0.9rem; color: #b3b3b3; margin: 4px 0 0 0; }
    /* --- Soundboard Grid --- */
    .board { display: grid; width: 100%; max-width: 420px; gap: 12px; grid-template-areas: "prev next" "clock play" "volDown play" "volUp play" "liked liked"; grid-template-columns: 1fr 1fr; }
    /* --- Base Button Style --- */
    .board button { display: flex; align-items: center; justify-content: center; padding: 16px; border-radius: 12px; border: 0; background: #0a0a0e; color: #fff; cursor: pointer; min-height: 80px; transition: background-color 0.2s; }
    .board button:hover { background: #1a1a1e; }
    .board button:active { background: #2a2a2e; }
    .board button svg { width: 28px; height: 28px; fill: #fff; }
    /* --- Assign buttons to grid areas --- */
    #prev { grid-area: prev; }
    #next { grid-area: next; }
    #clock { grid-area: clock; }
    #volDown { grid-area: volDown; }
    #volUp { grid-area: volUp; }
    #playLiked { grid-area: liked; }
    #playPause { grid-area: play; min-height: 276px; border-radius: 16px; }
    #playPause svg { width: 48px; height: 48px; }
    #clock { font-size: 2.5rem; font-weight: 600; font-family: 'Courier New', Courier, monospace; color: #fff; background: #0a0a0e; border-radius: 12px; display: flex; align-items: center; justify-content: center; cursor: pointer; user-select: none; }
    #clock:hover { background: #1a1a1e; }
    /* --- Fullscreen Mode --- */
    body:fullscreen, body:-webkit-full-screen { padding: 0; gap: 0; background: #0a0a0e; }
    body:fullscreen .auth-area, body:fullscreen .info, body:fullscreen hr, body:-webkit-full-screen .auth-area, body:-webkit-full-screen .info, body:-webkit-full-screen hr { display: none; }
    body:fullscreen .track-info, body:fullscreen .board, body:-webkit-full-screen .track-info, body:-webkit-full-screen .board { max-width: 100%; width: 100%; border-radius: 0; }
    body:fullscreen .track-info, body:-webkit-full-screen .track-info { flex-shrink: 0; min-height: 112px; }
    body:fullscreen .board, body:-webkit-full-screen .board { flex-grow: 1; height: 100%; padding: 16px; box-sizing: border-box; }
    body:fullscreen #playPause, body:-webkit-full-screen #playPause { min-height: 0; height: 100%; }
    @media (orientation: landscape) {
      body:fullscreen .board, body:-webkit-full-screen .board { grid-template-areas: "track prev next" "track play play" "track play play" "track volDown volUp" "track clock liked"; grid-template-columns: 2fr 1fr 1fr; grid-template-rows: repeat(5, 1fr); gap: 12px; }
      body:fullscreen .track-info, body:-webkit-full-screen .track-info { display: flex; grid-area: track; height: 100%; min-height: 0; }
      body:fullscreen #prev, body:-webkit-full-screen #prev { grid-area: prev; }
      body:fullscreen #next, body:-webkit-full-screen #next { grid-area: next; }
      body:fullscreen #clock, body:-webkit-full-screen #clock { grid-area: clock; }
      body:fullscreen #volDown, body:-webkit-full-screen #volDown { grid-area: volDown; }
      body:fullscreen #volUp, body:-webkit-full-screen #volUp { grid-area: volUp; }
      body:fullscreen #playLiked, body:-webkit-full-screen #playLiked { grid-area: liked; }
      body:fullscreen #playPause, body:-webkit-full-screen #playPause { grid-area: play; }
    }
  </style>
</head>
<body>

  <div class="info" id="status">Not signed in</div>
  <div class="auth-area">
    <div class="auth-buttons">
      <button id="btnAuth">Sign In</button>
      <button id="btnSignOut" class="muted">Sign Out</button>
    </div>
  </div>
  
  <hr style="width: 100%; max-width: 500px; border-color: #333;">

  <div class="track-info" id="trackInfo">
    <div class="track-name">No track playing</div>
    <div class="track-artist"></div>
  </div>

  <div class="board">
    <button id="prev" title="Previous"><svg viewBox="0 0 24 24"><path d="M17.51 3.87L15.73 2.1 5.84 12l9.9 9.9 1.77-1.77L9.38 12l8.13-8.13z"/></svg></button>
    <button id="next" title="Next"><svg viewBox="0 0 24 24"><path d="M6.49 3.87L8.27 2.1l9.89 9.9-9.9 9.9-1.77-1.77L14.62 12l-8.13-8.13z"/></svg></button>
    <div id="clock" title="Toggle Fullscreen">00:00</div>
    <button id="playPause" title="Play/Pause">
      <svg id="icon-play" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
      <svg id="icon-pause" viewBox="0 0 24 24" style="display: none;"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
    </button>
    <button id="volDown" title="Volume Down"><svg viewBox="0 0 24 24"><path d="M18.5 12c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM5 9v6h4l5 5V4L9 9H5z"/></svg></button>
    <button id="volUp" title="Volume Up"><svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg></button>
    <button id="playLiked" title="Play Liked Songs"><svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg></button>
  </div>

  <script>
    // --- Configuration ---
    const CLIENT_ID = 'bb82c1e306e44bc681b5fc345b2b493f';
    const REDIRECT_URI = 'https://valo-valox.github.io/spotify-soundboard/';
    
    // --- Spotify API Constants ---
    const AUTHORIZE_URL = 'https://accounts.spotify.com/authorize';
    const TOKEN_URL = 'https://accounts.spotify.com/api/token';
    const API_BASE_URL = 'https://api.spotify.com/v1';

    const SCOPES = [
      'streaming', 
      'user-modify-playback-state',
      'user-read-playback-state',
      'user-read-currently-playing',
      'user-library-read',
      'user-read-private'
    ].join(' ');

    // --- DOM Elements ---
    const $status = document.getElementById('status');
    const $trackInfo = document.getElementById('trackInfo');
    const $trackName = $trackInfo.querySelector('.track-name');
    const $trackArtist = $trackInfo.querySelector('.track-artist');
    const $iconPlay = document.getElementById('icon-play');
    const $iconPause = document.getElementById('icon-pause');
    const $clock = document.getElementById('clock');

    // --- State ---
    let player = null; 
    let deviceId = null; 
    let currentVolume = 0.5;

    // --- Helpers ---
    function setStatus(s) { $status.textContent = s; }
    function randomString(length) {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      let r = '';
      for (let i = 0; i < length; i++) r += chars.charAt(Math.floor(Math.random() * chars.length));
      return r;
    }
    async function sha256(plain) {
      const encoder = new TextEncoder();
      const data = encoder.encode(plain);
      return await crypto.subtle.digest('SHA-256', data);
    }
    function base64UrlEncode(bytes) {
      return btoa(String.fromCharCode(...new Uint8Array(bytes)))
        .replace(/=+$/, '').replace(/\+/g, '-').replace(/\//g, '_');
    }
    async function makeCodeChallenge(verifier) {
      const hashed = await sha256(verifier);
      return base64UrlEncode(hashed);
    }

    // --- Authentication Flow ---
    async function startAuth() {
      const state = randomString(16);
      const codeVerifier = randomString(64);
      const codeChallenge = await makeCodeChallenge(codeVerifier);

      localStorage.setItem('pkce_code_verifier', codeVerifier);
      localStorage.setItem('pkce_state', state);

      const params = new URLSearchParams({
        client_id: CLIENT_ID,
        response_type: 'code',
        redirect_uri: REDIRECT_URI,
        code_challenge_method: 'S256',
        code_challenge: codeChallenge,
        state: state,
        scope: SCOPES
      });
      window.location = `${AUTHORIZE_URL}?${params.toString()}`;
    }

    async function handleCallback() {
      const params = new URLSearchParams(window.location.search);
      const code = params.get('code');
      const state = params.get('state');
      if (!code) return;

      const storedState = localStorage.getItem('pkce_state');
      if (state !== storedState) {
        setStatus('State mismatch error.');
        return;
      }

      setStatus('Exchanging code for token...');
      const codeVerifier = localStorage.getItem('pkce_code_verifier');
      const body = new URLSearchParams({
        grant_type: 'authorization_code',
        code: code,
        redirect_uri: REDIRECT_URI,
        client_id: CLIENT_ID,
        code_verifier: codeVerifier
      });

      try {
        const res = await fetch(TOKEN_URL, { method: 'POST', body: body });
        if (!res.ok) throw new Error(await res.text());

        const data = await res.json();
        localStorage.setItem('sp_access_token', data.access_token);
        localStorage.setItem('sp_refresh_token', data.refresh_token || '');
        const expiresAt = Date.now() + (data.expires_in || 3600) * 1000;
        localStorage.setItem('sp_expires_at', expiresAt);

        setStatus('Signed in successfully!');
        history.replaceState(null, '', window.location.pathname);
      } catch (e) {
        setStatus(`Error during token exchange: ${e.message}`);
      }
    }

    async function refreshTokenIfNeeded() {
      const expiresAt = Number(localStorage.getItem('sp_expires_at') || 0);
      if (Date.now() < expiresAt - 60000) return localStorage.getItem('sp_access_token');

      const refresh_token = localStorage.getItem('sp_refresh_token');
      if (!refresh_token) {
        setStatus('Signed out. Please sign in again.');
        localStorage.clear();
        updateUI(null);
        return null;
      }

      setStatus('Refreshing token...');
      const body = new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: refresh_token,
        client_id: CLIENT_ID
      });

      try {
        const res = await fetch(TOKEN_URL, { method: 'POST', body: body });
        if (!res.ok) throw new Error('Refresh failed');

        const data = await res.json();
        localStorage.setItem('sp_access_token', data.access_token);
        if (data.refresh_token) {
          localStorage.setItem('sp_refresh_token', data.refresh_token);
        }
        const expiresAtNew = Date.now() + (data.expires_in || 3600) * 1000;
        localStorage.setItem('sp_expires_at', expiresAtNew);
        setStatus('Token refreshed.');
        return data.access_token;
      } catch (e) {
        setStatus(`Token refresh failed. Please sign in again.`);
        localStorage.clear();
        updateUI(null);
        return null;
      }
    }

    // --- API Wrapper ---
    async function api(path, method = 'GET', body = null) {
      const token = await refreshTokenIfNeeded();
      if (!token) throw new Error('Not signed in.');

      const headers = { 'Authorization': `Bearer ${token}` };
      if (body) {
        headers['Content-Type'] = 'application/json';
      }

      const res = await fetch(API_BASE_URL + path, {
        method,
        headers,
        body: body ? JSON.stringify(body) : null
      });

      if (res.status === 204) return null;
      const text = await res.text();
      if (!res.ok) {
        throw new Error(`API Error: ${res.status} ${text}`);
      }
      return text ? JSON.parse(text) : null;
    }

    // --- NEW: Function to transfer playback ---
    async function transferPlayback(newDeviceId) {
      try {
        setStatus('Transferring playback to browser...');
        // This is the Web API call to change active device
        await api('/me/player', 'PUT', { 
          device_ids: [newDeviceId],
          play: false // Set to false to just transfer, not auto-play
        });
        setStatus('Soundboard is active.');
      } catch (e) {
        // This can fail if the user is in a private session
        setStatus(`Could not transfer: ${e.message}`);
        console.warn("Could not auto-transfer playback. User may need to do it manually.");
      }
    }

    // --- Web Playback SDK Initialization ---
    function initializeSpotifyPlayer(token) {
      window.onSpotifyWebPlaybackSDKReady = () => {
        setStatus('Web Playback SDK ready.');
        player = new Spotify.Player({
          name: 'Valo-Valox Soundboard',
          getOAuthToken: cb => { 
            refreshTokenIfNeeded().then(freshToken => {
              cb(freshToken);
            });
          },
          volume: currentVolume
        });

        // --- Player Event Listeners ---
        player.addListener('ready', ({ device_id }) => {
          console.log('Player ready with Device ID', device_id);
          deviceId = device_id; // Store the new device_id
          
          // --- THIS IS THE NEW, CRITICAL STEP ---
          // Automatically make this browser the active player
          transferPlayback(device_id);
          // --- END NEW STEP ---
        });

        player.addListener('not_ready', ({ device_id }) => {
          console.log('Device ID has gone offline', device_id);
          deviceId = null;
          setStatus('Soundboard offline.');
        });

        player.addListener('player_state_changed', (state) => {
          if (!state) {
            updateUI(null);
            return;
          }
          // This event now controls the UI
          updateUI(state);
        });

        player.addListener('initialization_error', ({ message }) => { setStatus(`Init Error: ${message}`); });
        player.addListener('authentication_error', ({ message }) => { setStatus(`Auth Error: ${message}`); localStorage.clear(); });
        player.addListener('account_error', ({ message }) => { setStatus(`Account Error: ${message}`); });

        player.connect().then(success => {
          if (success) {
            console.log('The Web Playback SDK successfully connected!');
          }
        });
      };
    }
    
    // --- Playback Control Functions ---
    function updateUI(state) {
      if (!state) {
        $iconPlay.style.display = 'block';
        $iconPause.style.display = 'none';
        $trackName.textContent = 'No track playing';
        $trackArtist.textContent = 'Soundboard is idle';
        return;
      }

      if (state.paused) {
        $iconPlay.style.display = 'block';
        $iconPause.style.display = 'none';
      } else {
        $iconPlay.style.display = 'none';
        $iconPause.style.display = 'block';
      }

      const currentTrack = state.track_window.current_track;
      if (currentTrack) {
        const artists = currentTrack.artists..map(a => a.name).join(', ');
        $trackName.textContent = currentTrack.name;
        $trackArtist.textContent = artists;
      } else {
        $trackName.textContent = 'No track playing';
        $trackArtist.textContent = '';
      }
    }

    // --- SDK Player Functions ---
    async function togglePlayPause() {
      if (!player) return;
      await player.togglePlay();
    }
    
    async function next() {
      if (!player) return;
      await player.nextTrack();
    }
    
    async function previous() {
      if (!player) return;
      await player.previousTrack();
    }
    
    async function setVolume(v) {
      if (!player) return;
      currentVolume = Math.max(0, Math.min(1, v));
      await player.setVolume(currentVolume);
      setStatus(`Volume ${Math.round(currentVolume * 100)}%`);
    }
    
    // --- Web API Function (for playing specific context) ---
    async function playLikedSongs() {
      if (!deviceId) {
        setStatus('Player not ready yet.');
        return;
      }
      try {
        setStatus('Getting user info...');
        const userProfile = await api('/me');
        if (!userProfile || !userProfile.id) {
          setStatus('Could not get user ID');
          return;
        }
        const contextUri = `spotify:user:${userProfile.id}:collection`;
        
        setStatus('Playing Liked Songs...');
        await api('/me/player/play', 'PUT', { 
          context_uri: contextUri,
          device_id: deviceId // Target *this* browser
        });
      } catch (e) {
        setStatus(e.message);
      }
    }
    
    // --- Clock & Fullscreen ---
    function updateClock() {
      const now = new Date();
      const hours = String(now.getHours()).padStart(2, '0');
      const minutes = String(now.getMinutes()).padStart(2, '0');
      $clock.textContent = `${hours}:${minutes}`;
    }
    
    function toggleFullscreen() {
      if (!document.fullscreenElement && !document.webkitFullscreenElement) {
        const el = document.documentElement;
        if (el.requestFullscreen) el.requestFullscreen({ navigationUI: "hide" });
        else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
        if (screen.orientation && screen.orientation.lock) screen.orientation.lock('landscape').catch(() => {});
      } else {
        if (document.exitFullscreen) document.exitFullscreen();
        else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
      }
    }

    // --- UI Event Listeners ---
    document.getElementById('btnAuth').addEventListener('click', startAuth);

    document.getElementById('btnSignOut').addEventListener('click', () => {
      if (player) player.disconnect(); 
      player = null;
      deviceId = null;
      localStorage.clear();
      setStatus('Signed out');
      updateUI(null);
    });

    function addApiListener(id, action) {
      document.getElementById(id).addEventListener('click', () => {
        if (!player || !deviceId) {
          setStatus('Player not ready. Please wait.');
          return;
        }
        action().catch(e => setStatus(e.message));
      });
    }

    addApiListener('playPause', togglePlayPause);
    addApiListener('next', next);
    addApiListener('prev', previous);
    addApiListener('playLiked', playLikedSongs);
    $clock.addEventListener('click', toggleFullscreen);

    document.getElementById('volUp').addEventListener('click', () => {
      if (!player) return;
      setVolume(currentVolume + 0.1).catch(e => setStatus(e.message));
    });

    document.getElementById('volDown').addEventListener('click', () => {
      if (!player) return;
      setVolume(currentVolume - 0.1).catch(e => setStatus(e.message));
    });
    
    // --- Page Load ---
    window.addEventListener('load', async () => {
      updateClock();
      setInterval(updateClock, 1000);
      
      if (window.location.search.includes('code=')) {
        await handleCallback();
      }
      
      const token = await refreshTokenIfNeeded();
      
      if (token) {
        setStatus('Signed in. Loading player...');
        initializeSpotifyPlayer(token);
      } else {
        setStatus('Not signed in');
      }
    });
  </script>
</body>
</html>
